# Copyright (c) 2010-2012 Lazy 8 Studios, LLC.
# All rights reserved.
# This code was adapted from the the django project, especially from:
# http://code.djangoproject.com/svn/django/trunk/django/contrib/auth/tokens.py
import hmac
import hashlib
from datetime import datetime

from front.lib import utils, gametime

# Token timestamps are number of seconds since this epoch.
TIMESTAMP_EPOCH = datetime(2012, 1, 1, 0, 0, 0, 0)

# A singleton for this module as a convenience. Must be initialized with init_module before use.
_default_generator = None
def init_module(secret_key):
    global _default_generator
    _default_generator = TokenGenerator(secret_key)

# Module singleton convenience wrappers.
def make_token(namespace, *args): return _default_generator.make_token(namespace, *args)
def make_token_with_timestamp(namespace, *args): return _default_generator.make_token_with_timestamp(namespace, *args)
def check_token(namespace, token, *args): return _default_generator.check_token(namespace, token, *args)
def check_token_with_timestamp(namespace, token, ts_encoded, expire_seconds, *args):
    return _default_generator.check_token_with_timestamp(namespace, token, ts_encoded, expire_seconds, *args)

class TokenGenerator(object):
    def __init__(self, secret_key):
        self._secret_key = secret_key

    def make_token(self, namespace, *args):
        """
        Generates a secure base62 encoded token string, which is a tamper resistant signature
        for all of the supplied components (converted to unicode objects) passed in via *args.
        :param namespace: A string used to 'namespace' this token. It should be different for each
            use case for a given set of components as it will generate unique tokens for the same set of
            *args components.
        Returns the base62 encoded token.

        >>> gen = TokenGenerator("secret_key")
        >>> token = gen.make_token("namespace", "value1", "value2")
        >>> token
        '582w2nu9NG3yTf'
        >>> gen.check_token("namespace", token, "value1", "value2")
        True
        >>> gen.check_token("namespace", token, "value1_tampered", "value2")
        False

        >>> init_module("secret_key")
        >>> token = make_token("namespace", "value1", "value2")
        >>> token
        '582w2nu9NG3yTf'
        >>> check_token("namespace", token, "value1", "value2")
        True
        """
        return self._make_token_for_components(namespace, *args)

    def make_token_with_timestamp(self, namespace, *args):
        """
        Generates a secure base62 encoded token string, which is a tamper resistant signature
        for all of the supplied components (converted to unicode objects) passed in via *args.
        :param namespace: A string used to 'namespace' this token. It should be different for each
            use case for a given set of components as it will generate unique tokens for the same set of
            *args components.
        Returns the base62 encoded token and timestamp as a tuple.

        >>> gen = TokenGenerator("secret_key")
        >>> gen._now = lambda: datetime(2012, 8, 1, 8, 0, 0, 0)
        >>> token, ts = gen.make_token_with_timestamp("namespace", "value1", "value2")
        >>> token
        '2YqQ0UPqy3KsPZ'
        >>> ts
        '1FL0K'
        >>> gen.check_token_with_timestamp("namespace", token, ts, 60, "value1", "value2")
        True
        >>> gen._now = lambda: datetime(2012, 8, 1, 8, 1, 1, 0) # 61 seconds later.
        >>> gen.check_token_with_timestamp("namespace", token, ts, 60, "value1", "value2")
        False
        """
        # timestamp is number of seconds since 2012-1-1.  Converted to
        # base 62, this gives us a 5 digit string for a number of years.
        ts_encoded = utils.int_to_base62(self._current_timestamp())

        return (self.make_token(namespace, ts_encoded, *args), ts_encoded)

    def check_token(self, namespace, token, *args):
        """
        Verify the given token, generated by make_token, is valid in the given namespace for the
        supplied components passed via *args.
        Returns True if valid, False otherwise.
        """
        # Check that the token componenets have not been tampered with
        if not utils.constant_time_compare(self._make_token_for_components(namespace, *args), token):
            return False

        return True

    def check_token_with_timestamp(self, namespace, token, ts_encoded, expire_seconds, *args):
        """
        Verify the given token, generated by make_token, is valid in the given namespace for the
        supplied components passed via *args.
        :param ts_encoded: The base62 encoded timestamp generated with this token.
        :param expire_seconds: The number of seconds past the supplied timestamp when this token
            will be expired, resulting in False being returned from this function.
        Returns True if valid, False otherwise.
        """
        try:
            ts = utils.base62_to_int(ts_encoded)
        except ValueError:
            return False

        # Check that the timestamp and other token componenets have not been tampered with.
        if not utils.constant_time_compare(self._make_token_for_components(namespace, ts_encoded, *args), token):
            return False

        # Check the timestamp is within limit, otherwise it has expired.
        if (self._current_timestamp() - ts) > expire_seconds:
            return False

        return True

    ## Module helper functions
    def _make_token_for_components(self, namespace, *args):
        # Collapse all of the token components into a single string.
        value = "".join([unicode(a) for a in args])

        # Generate the hmac salted hash of all the components and the secret key.
        # Reduce the size of the hash by a factor of 2 to have a 14 character token string in order
        # to keep URLs relatively short. This reduces the complexity of the hash function and raises the probability of
        # a collision but in normal use these tokens are acting more like a difficult to guess checksum rather than
        # requiring true uniqueness.
        # See: http://en.wikipedia.org/wiki/Birthday_problem
        hashed = _salted_hmac(namespace, value, self._secret_key).hexdigest()[::2]

        # Return the hash as a base62 encoded integer.
        return utils.int_to_base62(int(hashed, 16))

    def _current_timestamp(self):
        return utils.seconds_between_datetimes(TIMESTAMP_EPOCH, self._now())

    def _now(self):
        return gametime.now()

def _salted_hmac(key_salt, value, secret):
    """
    Returns the HMAC-SHA1 of 'value', using a key generated from key_salt and a secret.

    A different key_salt should be passed in for every application of HMAC.
    Lifted from: http://code.djangoproject.com/svn/django/trunk/django/utils/crypto.py
    """
    # We need to generate a derived key from our base key.  We can do this by
    # passing the key_salt and our base key through a pseudo-random function and
    # SHA1 works nicely.
    key = hashlib.sha1(key_salt + secret).digest()

    # If len(key_salt + secret) > sha_constructor().block_size, the above
    # line is redundant and could be replaced by key = key_salt + secret, since
    # the hmac module does the same thing for keys longer than the block size.
    # However, we need to ensure that we *always* do this.
    return hmac.new(key, msg=value, digestmod=hashlib.sha1)
